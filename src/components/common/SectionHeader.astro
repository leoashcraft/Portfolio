---
interface Props {
  title: string;
  titleHighlight: string;
  subtitle: string;
  headingId?: string;
}

const { title, titleHighlight, subtitle, headingId } = Astro.props;
const subtitleId = headingId ? `${headingId}-subtitle` : `subtitle-${Math.random().toString(36).slice(2, 9)}`;
---

<div class="text-center mb-16 section-header-container">
  <h2 id={headingId} class="section-title section-title-anim">
    {title} <span class="gradient-text">{titleHighlight}</span>
  </h2>
  <p class="section-subtitle section-subtitle-anim mx-auto relative">
    <span class="subtitle-placeholder invisible" aria-hidden="true">{subtitle}</span>
    <span class="subtitle-typewriter absolute left-0 right-0 top-0">
      <span class="subtitle-text" data-subtitle={subtitle} id={subtitleId}></span><span class="subtitle-cursor hidden inline-block w-[2px] h-[1em] bg-neon-cyan ml-1 align-middle animate-[cursor-blink_1s_step-end_infinite]"></span>
    </span>
  </p>
</div>

<script>
  // Scroll-driven wave and typewriter animations
  interface HeaderState {
    titleEl: HTMLElement;
    subtitleTextEl: HTMLElement;
    cursorEl: HTMLElement;
    letters: HTMLSpanElement[];
    subtitle: string;
    lastProgress: number;
    lastTypeProgress: number;
  }

  const headerStates = new Map<Element, HeaderState>();

  function wrapLetters(titleEl: HTMLElement): HTMLSpanElement[] {
    const letters: HTMLSpanElement[] = [];

    // Process all child nodes
    const processNode = (node: Node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || '';
        const fragment = document.createDocumentFragment();

        for (const char of text) {
          if (char === ' ' || char === '\n' || char === '\t') {
            fragment.appendChild(document.createTextNode(char));
          } else {
            const span = document.createElement('span');
            span.className = 'wave-letter';
            span.style.display = 'inline-block';
            span.textContent = char;
            letters.push(span);
            fragment.appendChild(span);
          }
        }

        node.parentNode?.replaceChild(fragment, node);
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const el = node as HTMLElement;
        // Check if it's a gradient-text span
        const isGradient = el.classList.contains('gradient-text');
        const gradientStyle = isGradient ? getComputedStyle(el).backgroundImage : '';

        // Process children
        Array.from(el.childNodes).forEach(child => {
          if (child.nodeType === Node.TEXT_NODE) {
            const text = child.textContent || '';
            const fragment = document.createDocumentFragment();

            for (const char of text) {
              if (char === ' ' || char === '\n' || char === '\t') {
                fragment.appendChild(document.createTextNode(char));
              } else {
                const span = document.createElement('span');
                span.className = 'wave-letter';
                span.style.display = 'inline-block';
                span.textContent = char;

                if (isGradient && gradientStyle) {
                  span.style.backgroundImage = gradientStyle;
                  span.style.backgroundClip = 'text';
                  span.style.webkitBackgroundClip = 'text';
                  span.style.color = 'transparent';
                }

                letters.push(span);
                fragment.appendChild(span);
              }
            }

            child.parentNode?.replaceChild(fragment, child);
          }
        });
      }
    };

    Array.from(titleEl.childNodes).forEach(processNode);
    return letters;
  }

  function initScrollDrivenHeaders() {
    const containers = document.querySelectorAll('.section-header-container');

    // Check if animations are disabled
    const animationsDisabled = document.documentElement.getAttribute('data-animations') === 'disabled';

    containers.forEach((container) => {
      const titleEl = container.querySelector('.section-title') as HTMLElement;
      const subtitleTextEl = container.querySelector('.subtitle-text') as HTMLElement;
      const cursorEl = container.querySelector('.subtitle-cursor') as HTMLElement;

      if (!titleEl || !subtitleTextEl) return;

      const subtitle = subtitleTextEl.dataset.subtitle || '';

      // If animations disabled, show everything immediately
      if (animationsDisabled) {
        subtitleTextEl.textContent = subtitle;
        if (cursorEl) {
          cursorEl.classList.add('hidden');
          cursorEl.style.display = 'none';
        }
        const title = container.querySelector('.section-title-anim');
        const sub = container.querySelector('.section-subtitle-anim');
        if (title) title.classList.add('visible');
        if (sub) sub.classList.add('visible');
        return;
      }

      // Wrap letters if not already done
      let letters = Array.from(titleEl.querySelectorAll('.wave-letter')) as HTMLSpanElement[];
      if (letters.length === 0) {
        letters = wrapLetters(titleEl);
      }

      // Show cursor
      if (cursorEl) {
        cursorEl.classList.remove('hidden');
        cursorEl.style.display = '';
      }

      // Store state
      headerStates.set(container, {
        titleEl,
        subtitleTextEl,
        cursorEl,
        letters,
        subtitle,
        lastProgress: -1,
        lastTypeProgress: -1
      });
    });

    let ticking = false;

    const updateHeaders = () => {
      const viewportHeight = window.innerHeight;

      // Wave animation range: from 85% to 40% of viewport (top of container)
      const waveStart = viewportHeight * 0.85;
      const waveEnd = viewportHeight * 0.40;

      // Typewriter range: from 70% to 25% of viewport
      const typeStart = viewportHeight * 0.70;
      const typeEnd = viewportHeight * 0.25;

      headerStates.forEach((state, container) => {
        const rect = container.getBoundingClientRect();
        const title = container.querySelector('.section-title-anim');
        const sub = container.querySelector('.section-subtitle-anim');

        // Calculate wave progress (0 = not started, 1 = complete)
        let waveProgress = 0;
        if (rect.top <= waveStart && rect.top >= waveEnd) {
          waveProgress = (waveStart - rect.top) / (waveStart - waveEnd);
        } else if (rect.top < waveEnd) {
          waveProgress = 1;
        }

        // Calculate typewriter progress
        let typeProgress = 0;
        if (rect.top <= typeStart && rect.top >= typeEnd) {
          typeProgress = (typeStart - rect.top) / (typeStart - typeEnd);
        } else if (rect.top < typeEnd) {
          typeProgress = 1;
        }

        // Show/hide title and subtitle containers based on progress
        if (waveProgress > 0) {
          if (title) title.classList.add('visible');
        } else {
          if (title) title.classList.remove('visible');
        }

        if (typeProgress > 0) {
          if (sub) sub.classList.add('visible');
        } else {
          if (sub) sub.classList.remove('visible');
        }

        // Apply wave animation to letters
        if (Math.abs(waveProgress - state.lastProgress) > 0.001) {
          state.lastProgress = waveProgress;

          const totalLetters = state.letters.length;
          const letterWindow = 0.15;

          // When wave is complete, all letters should be at normal scale
          if (waveProgress >= 0.95) {
            state.letters.forEach((letter) => {
              letter.style.transform = 'scale(1)';
              letter.style.filter = '';
            });
          } else {
            state.letters.forEach((letter, index) => {
              // Map letter peaks to 0-0.85 range so wave finishes before progress reaches 1
              const letterPeak = (index / totalLetters) * 0.85;
              const distFromPeak = Math.abs(waveProgress - letterPeak);

              let scale = 1;
              if (distFromPeak < letterWindow) {
                const normalizedDist = distFromPeak / letterWindow;
                scale = 1 + 0.4 * (1 - normalizedDist * normalizedDist);
              }

              let brightness = 1;
              if (distFromPeak < letterWindow * 0.5) {
                brightness = 1.3;
              }

              letter.style.transform = `scale(${scale})`;
              letter.style.filter = brightness > 1 ? `brightness(${brightness})` : '';
            });
          }
        }

        // Apply typewriter effect
        if (Math.abs(typeProgress - state.lastTypeProgress) > 0.001) {
          state.lastTypeProgress = typeProgress;

          if (typeProgress >= 0.95) {
            state.subtitleTextEl.textContent = state.subtitle;
          } else {
            const charsToShow = Math.floor(typeProgress * state.subtitle.length);
            state.subtitleTextEl.textContent = state.subtitle.slice(0, charsToShow);
          }

          // Show/hide cursor
          if (state.cursorEl) {
            if (typeProgress > 0 && typeProgress < 1) {
              state.cursorEl.style.display = '';
            } else if (typeProgress >= 0.95) {
              state.cursorEl.style.display = 'none';
            } else {
              state.cursorEl.style.display = '';
            }
          }
        }
      });

      ticking = false;
    };

    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(updateHeaders);
        ticking = true;
      }
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    updateHeaders();

    return () => {
      window.removeEventListener('scroll', handleScroll);
      headerStates.clear();
    };
  }

  // Handle animations state changes
  function handleAnimationsChange() {
    const animationsDisabled = document.documentElement.getAttribute('data-animations') === 'disabled';
    const containers = document.querySelectorAll('.section-header-container');

    containers.forEach((container) => {
      const textEl = container.querySelector('.subtitle-text') as HTMLElement;
      const cursorEl = container.querySelector('.subtitle-cursor') as HTMLElement;
      const title = container.querySelector('.section-title-anim');
      const sub = container.querySelector('.section-subtitle-anim');

      if (!textEl) return;

      if (animationsDisabled) {
        const subtitle = textEl.dataset.subtitle || '';
        textEl.textContent = subtitle;
        if (cursorEl) {
          cursorEl.classList.add('hidden');
          cursorEl.style.display = 'none';
        }
        if (title) title.classList.add('visible');
        if (sub) sub.classList.add('visible');

        // Reset letter transforms
        const letters = container.querySelectorAll('.wave-letter') as NodeListOf<HTMLSpanElement>;
        letters.forEach(letter => {
          letter.style.transform = '';
          letter.style.filter = '';
        });
      }
    });
  }

  let headerCleanup: (() => void) | undefined;

  function initHeaders() {
    headerCleanup?.();
    headerCleanup = initScrollDrivenHeaders();
  }

  initHeaders();
  document.addEventListener('astro:after-swap', initHeaders);

  window.addEventListener('animations-change', () => {
    handleAnimationsChange();
    headerCleanup?.();
    headerCleanup = initScrollDrivenHeaders();
  });
</script>

<style>
  /* Section header visibility */
  .section-title-anim {
    opacity: 0;
    transition: opacity 0.3s ease-out;
  }

  .section-subtitle-anim {
    opacity: 0;
    transition: opacity 0.3s ease-out;
  }

  .section-title-anim.visible {
    opacity: 1;
  }

  .section-subtitle-anim.visible {
    opacity: 1;
  }

  /* Wave letter smooth transitions */
  .section-title .wave-letter {
    transition: transform 0.1s ease-out, filter 0.1s ease-out;
  }

  /* Disable animations when preference set */
  [data-animations="disabled"] .section-title-anim,
  [data-animations="disabled"] .section-subtitle-anim {
    opacity: 1 !important;
    transition: none !important;
  }

  [data-animations="disabled"] .section-title .wave-letter {
    transform: none !important;
    filter: none !important;
    transition: none !important;
  }
</style>
