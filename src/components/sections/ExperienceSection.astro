---
import { experience, education } from '../../data/experience';
import { site } from '../../data/site';
import SectionHeader from '../common/SectionHeader.astro';
import ArcadeDecorations from '../common/ArcadeDecorations.astro';
import Icon from '../ui/Icon.astro';
---

<section id="experience" class="section section-arcade-alt" aria-labelledby="experience-heading">
  <!-- Neon Top Border -->
  <div class="absolute top-0 left-0 right-0 h-px bg-gradient-to-r from-transparent via-neon-pink/50 to-transparent"></div>

  <!-- Floating Arcade Decorations -->
  <ArcadeDecorations variant="experience" />

  <!-- Experience Timeline â€” vertical scroll panels -->
  <div class="exp-vscroll-section relative z-10">
    <div class="exp-vscroll-container">
      <!-- Section Header pinned inside sticky -->
      <div class="exp-vscroll-header">
        <SectionHeader
          title={site.sections.experience.title}
          titleHighlight={site.sections.experience.titleHighlight}
          subtitle={site.sections.experience.subtitle}
          headingId="experience-heading"
        />
      </div>

      <div class="exp-vscroll-viewport">
        <!-- Timeline Line -->
        <div
          id="timeline-line"
          class="hidden md:block absolute right-4 md:left-auto lg:left-1/2 lg:right-auto top-0 w-0.5 lg:-translate-x-1/2 timeline-gradient"
          style="height: 0px;"
          aria-hidden="true"
        ></div>

        <!-- Eyes â€” positioned independently, JS syncs to line tip -->
        <div
          id="timeline-eyes"
          class="hidden md:block absolute right-4 md:left-auto lg:left-1/2 lg:right-auto timeline-traveler text-[1.81rem] look-left pointer-events-none z-20"
          style="filter: drop-shadow(0 0 8px rgba(255, 0, 255, 0.8)); opacity: 0; top: 0px;"
          aria-hidden="true"
        >
          <span class="eyes-blink">ðŸ‘€</span>
        </div>

        <div class="exp-vscroll-track">
          {
            experience.map((exp, index) => (
              <div class="exp-vscroll-panel">
                <div
                  class={`experience-item relative flex flex-col lg:flex-row gap-8 ${
                    index % 2 === 0 ? 'lg:flex-row-reverse' : ''
                  }`}
                >
                  {/* Content side */}
                  <div
                    class={`md:pr-12 lg:pr-0 lg:w-1/2 ${
                      index % 2 === 0 ? 'lg:pl-6' : 'lg:pr-6'
                    }`}
                  >
                    <div class="experience-card card" data-index={index}>
                      {/* Header */}
                      <div class="flex flex-wrap items-start justify-between gap-4 mb-4">
                        <div>
                          <p class="exp-title text-xl font-bold text-white">{exp.position}</p>
                          <p class="exp-company font-medium" style="color: #22CBCC;">{exp.company}</p>
                        </div>
                        <span class="exp-period text-sm text-gray-400 bg-night-700 px-3 py-1 rounded-full">
                          {exp.period}
                        </span>
                      </div>

                      {/* Location */}
                      {exp.location && (
                        <p class="exp-location text-gray-400 text-sm mb-4 flex items-center gap-2">
                          <svg
                            class="w-4 h-4"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                          >
                            <path
                              stroke-linecap="round"
                              stroke-linejoin="round"
                              stroke-width="2"
                              d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"
                            />
                            <path
                              stroke-linecap="round"
                              stroke-linejoin="round"
                              stroke-width="2"
                              d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"
                            />
                          </svg>
                          {exp.location}
                        </p>
                      )}

                      {/* Highlights */}
                      <ul class="exp-highlights space-y-2">
                        {exp.highlights.map((highlight) => (
                          <li class="exp-highlight flex items-start gap-3 text-gray-300 text-sm">
                            <svg
                              class="w-5 h-5 text-neon-green shrink-0 mt-0.5"
                              fill="none"
                              viewBox="0 0 24 24"
                              stroke="currentColor"
                            >
                              <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                              />
                            </svg>
                            <span>{highlight}</span>
                          </li>
                        ))}
                      </ul>
                    </div>
                  </div>

                  {/* Spacer for opposite side */}
                  <div class="hidden lg:block lg:w-1/2" />
                </div>
              </div>
            ))
          }
        </div>
      </div>{/* end .exp-vscroll-viewport */}

      {/* Panel indicator dots */}
      <div class="exp-vscroll-indicators">
        {experience.map((_, i) => (
          <button class={`exp-vscroll-dot${i === 0 ? ' active' : ''}`} data-panel={i} aria-label={`Go to experience ${i + 1}`}></button>
        ))}
      </div>
    </div>
  </div>
</section>

<!-- Education â€” own section, 100vh, snaps -->
<section id="education" class="education-section section section-arcade-alt" aria-labelledby="education-heading">
  <div class="education-inner max-w-6xl mx-auto relative z-10 px-4">
    <h3 id="education-heading" class="subsection-title education-title text-2xl font-bold text-white text-center mb-8">
      {site.sections.experience.educationTitle} <span class="gradient-text">{site.sections.experience.educationTitleHighlight}</span>
    </h3>

    <div class="education-grid max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-6">
      {
        education.map((edu, index) => (
          <div class={`card relative edu-card edu-card-${index} flex flex-col`}>
            <span class="absolute top-4 right-4 text-sm text-gray-400 bg-night-700 px-3 py-1 rounded-full year-counter" data-target-year={edu.year}>
              2000
            </span>
            <p class="text-lg font-bold text-white edu-degree-title mb-4">{edu.degree}</p>

            <div class="flex-1 flex flex-col justify-end">
              <p class="text-neon-yellow mb-2">
                {edu.institution === 'Meta' ? (
                  <a href="https://meta.com" target="_blank" rel="noopener noreferrer" class="text-neon-yellow hover:text-neon-yellow/80 transition-colors">
                    {edu.institution}
                  </a>
                ) : edu.institution === 'Coding Temple' ? (
                  <a href="https://codingtemple.com" target="_blank" rel="noopener noreferrer" class="text-neon-yellow hover:text-neon-yellow/80 transition-colors">
                    {edu.institution}
                  </a>
                ) : (
                  edu.institution
                )}
              </p>
              <p class="text-gray-400 text-sm mb-4">{edu.description}</p>

              <div class="flex flex-wrap items-center gap-2">
              {edu.skills.map((skill) => (
                <span class="px-3 py-1 text-xs bg-neon-pink/10 text-neon-pink rounded-full border border-neon-pink/20">
                  {skill}
                </span>
              ))}
              {edu.credentialUrl && (
                <a
                  href={edu.credentialUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  class="ml-auto inline-flex items-center gap-1 text-sm text-neon-cyan hover:text-neon-cyan/80 transition-colors"
                >
                  View Credential
                  <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                  </svg>
                </a>
              )}
              </div>
            </div>
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  /* ============================================
     Experience Vertical Scroll Section
     ============================================ */
  :global(#experience) {
    scroll-snap-align: start;
    min-height: auto;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
  }

  .exp-vscroll-section {
    position: relative;
  }

  .exp-vscroll-container {
    position: sticky;
    top: var(--nav-h, 60px);
    height: calc(100vh - var(--nav-h, 60px));
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .exp-vscroll-header {
    flex-shrink: 0;
    padding: 2rem 5% 0;
  }

  /* Track area fills remaining space after header */
  .exp-vscroll-viewport {
    flex: 1 1 0%;
    min-height: 0;
    overflow: hidden;
    position: relative;
  }

  .exp-vscroll-track {
    display: flex;
    flex-direction: column;
    will-change: transform;
    width: 100%;
  }

  /* Each panel fills the viewport area height and centers its card */
  .exp-vscroll-panel {
    width: 100%;
    flex: 0 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0 5%;
    box-sizing: border-box;
    /* Height set by JS to match viewport area */
  }

  /* Experience item layout (the flex row around timeline) */
  .experience-item {
    width: 100%;
    max-width: 1200px;
    position: relative;
  }

  /* Card content animations */
  .experience-card .exp-title,
  .experience-card .exp-company,
  .experience-card .exp-period,
  .experience-card .exp-location {
    opacity: 0;
    transform: translateY(-20px);
    transition: opacity 0.4s ease-out, transform 0.5s ease-out;
  }

  .experience-card .exp-highlight {
    opacity: 0;
    transform: translateY(-15px);
    transition: opacity 0.3s ease-out, transform 0.4s ease-out;
  }

  .experience-card.content-in .exp-title,
  .experience-card.content-in .exp-company,
  .experience-card.content-in .exp-period,
  .experience-card.content-in .exp-location {
    opacity: 1;
    transform: translateY(0);
  }

  .experience-card.highlights-in .exp-highlight {
    opacity: 1;
    transform: translateY(0);
  }

  /* Slide animation for card entering from left/right */
  .experience-item {
    opacity: 0;
    transition: opacity 0.5s ease-out, transform 0.5s ease-out;
  }

  /* Even index (flex-row-reverse) â€” card is on right, slides from right */
  .experience-item.lg\:flex-row-reverse {
    transform: translateX(60px);
  }

  /* Odd index â€” card is on left, slides from left */
  .experience-item:not(.lg\:flex-row-reverse) {
    transform: translateX(-60px);
  }

  .experience-item.slide-in {
    opacity: 1;
    transform: translateX(0);
  }

  /* Indicator dots â€” vertical on the right */
  .exp-vscroll-indicators {
    position: absolute;
    right: 2rem;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    z-index: 20;
  }

  .exp-vscroll-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid rgba(255, 0, 255, 0.4);
    background: transparent;
    transition: all 0.3s ease;
    cursor: pointer;
  }

  .exp-vscroll-dot.active {
    background: var(--color-neon-pink);
    border-color: var(--color-neon-pink);
    box-shadow: 0 0 10px rgba(255, 0, 255, 0.6);
  }

  /* Mobile: tighter padding for scroll panels */
  @media (max-width: 767px) {
    .exp-vscroll-header {
      padding: 1rem 1rem 0;
    }

    .exp-vscroll-panel {
      padding: 0 1rem;
    }
  }

  /* Disable animations */
  [data-animations="disabled"] .experience-item {
    opacity: 1 !important;
    transform: none !important;
    transition: none !important;
  }

  [data-animations="disabled"] .experience-card .exp-title,
  [data-animations="disabled"] .experience-card .exp-company,
  [data-animations="disabled"] .experience-card .exp-period,
  [data-animations="disabled"] .experience-card .exp-location,
  [data-animations="disabled"] .experience-card .exp-highlight {
    opacity: 1 !important;
    transform: none !important;
    transition: none !important;
  }

  [data-animations="disabled"] #timeline-line {
    height: 100% !important;
    transition: none !important;
  }

  [data-animations="disabled"] #timeline-eyes {
    opacity: 1 !important;
  }

  /* ============================================
     Education â€” own snapping section, 100vh
     ============================================ */
  .education-section {
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    scroll-snap-align: start;
    position: relative;
  }

  .education-inner {
    width: 100%;
  }

  /* Education title animation */
  .education-title {
    opacity: 0;
    transition: opacity 0.3s ease-out;
  }

  .education-title.visible {
    opacity: 1;
  }

  .education-title .wave-letter {
    transition: transform 0.1s ease-out, filter 0.1s ease-out;
  }

  /* Education cards fly in from their respective corners */
  .edu-card {
    opacity: 0;
    transform: scale(0.8);
    transition: opacity 0.15s ease-out, transform 0.15s ease-out;
  }

  /* Left card flies in from top-left */
  .edu-card-0 { transform: scale(0.8) translate(-60px, -60px); }
  /* Center card flies in from top */
  .edu-card-1 { transform: scale(0.8) translate(0, -60px); }
  /* Right card flies in from top-right */
  .edu-card-2 { transform: scale(0.8) translate(60px, -60px); }

  .education-grid.cards-in .edu-card {
    opacity: 1;
    transform: scale(1) translate(0, 0);
  }

  /* Slower exit transition so fly-out is visible */
  .education-grid.cards-out .edu-card {
    transition-duration: 0.4s;
  }

  .edu-card-0 { transition-delay: 0s; }
  .edu-card-1 { transition-delay: 0.1s; }
  .edu-card-2 { transition-delay: 0.2s; }

  /* Reverse stagger on exit â€” last card leaves first */
  .education-grid.cards-out .edu-card-0 { transition-delay: 0.2s; }
  .education-grid.cards-out .edu-card-1 { transition-delay: 0.1s; }
  .education-grid.cards-out .edu-card-2 { transition-delay: 0s; }

  /* Year chip only affects first line of degree title */
  .edu-card .year-counter {
    float: right;
    shape-outside: margin-box;
  }

  .edu-degree-title {
    overflow-wrap: break-word;
    word-wrap: break-word;
  }

  [data-animations="disabled"] .education-title,
  [data-animations="disabled"] .edu-card {
    opacity: 1 !important;
    transform: none !important;
    transition: none !important;
  }
</style>

<script>
  import { initSectionParallax } from '../../lib/parallax';
  import { initScrollWave } from '../../lib/scroll-wave';

  // Lazy-loaded sounds â€” created on first play to avoid autoplay restrictions
  let snapSound: HTMLAudioElement | null = null;
  let exitSlideSound: HTMLAudioElement | null = null;
  const SNAP_SOUND_URL = '/sounds/very-fast-cinematic-whoosh-327345.mp3';
  const EXIT_SLIDE_SOUND_URL = '/sounds/paper-slide-102746.mp3';

  function getSnapSound(): HTMLAudioElement | null {
    if (!snapSound) {
      try {
        snapSound = new Audio(SNAP_SOUND_URL);
        snapSound.volume = 0.3;
      } catch (_) { return null; }
    }
    return snapSound;
  }

  function getExitSlideSound(): HTMLAudioElement | null {
    if (!exitSlideSound) {
      try {
        exitSlideSound = new Audio(EXIT_SLIDE_SOUND_URL);
        exitSlideSound.volume = 0.3;
      } catch (_) { return null; }
    }
    return exitSlideSound;
  }

  let lastSoundTime = 0;
  function playSnapSound() {
    if (document.documentElement.getAttribute('data-sounds') === 'disabled') return;
    const now = Date.now();
    if (now - lastSoundTime < 1000) return;
    lastSoundTime = now;
    const snd = getSnapSound();
    if (!snd) return;
    snd.currentTime = 0;
    snd.play().catch(() => {});
  }

  function playExitSlideSound() {
    if (document.documentElement.getAttribute('data-sounds') === 'disabled') return;
    const snd = getExitSlideSound();
    if (!snd) return;
    snd.currentTime = 0;
    snd.play().catch(() => {});
  }

  function isMobile(): boolean {
    return false; // scroll panels now work on all screen sizes
  }

  // ============================================
  // Timeline Eyes (independent element, JS-positioned)
  // ============================================
  let hoverAnimId: number | null = null;
  let eyesBaseTop = 0; // the "rest" top position in px

  function startEyesHover(eyesEl: HTMLElement) {
    if (hoverAnimId !== null) return;
    const startTime = performance.now();
    function hover(now: number) {
      const t = (now - startTime) / 1000;
      const y = Math.sin(t * 2.5) * 4; // 4px bob
      eyesEl.style.top = `${eyesBaseTop + y}px`;
      hoverAnimId = requestAnimationFrame(hover);
    }
    hoverAnimId = requestAnimationFrame(hover);
  }

  function stopEyesHover() {
    if (hoverAnimId !== null) {
      cancelAnimationFrame(hoverAnimId);
      hoverAnimId = null;
    }
  }

  function setEyesDirection(eyesEl: HTMLElement, activeIndex: number) {
    const isRightSide = window.innerWidth >= 768 && window.innerWidth < 1024;
    if (isRightSide) {
      eyesEl.classList.add('look-right');
      eyesEl.classList.remove('look-left');
    } else {
      const cardOnRight = activeIndex % 2 === 0;
      eyesEl.classList.toggle('look-left', cardOnRight);
      eyesEl.classList.toggle('look-right', !cardOnRight);
    }
  }

  function blinkEyes(eyesEl: HTMLElement) {
    const eyesSpan = eyesEl.querySelector('.eyes-blink') as HTMLElement;
    if (eyesSpan) {
      eyesSpan.classList.add('blinking');
      setTimeout(() => eyesSpan.classList.remove('blinking'), 200);
    }
  }

  // ============================================
  // Experience Vertical Scroll
  // ============================================
  let expCleanup: (() => void) | undefined;

  function initExpVscroll() {
    const section = document.querySelector('.exp-vscroll-section') as HTMLElement;
    const container = document.querySelector('.exp-vscroll-container') as HTMLElement;
    const track = document.querySelector('.exp-vscroll-track') as HTMLElement;
    const dots = document.querySelectorAll('.exp-vscroll-dot') as NodeListOf<HTMLElement>;
    const timelineLine = document.getElementById('timeline-line');
    const timelineEyes = document.getElementById('timeline-eyes');

    if (!section || !container || !track) return () => {};

    const panels = track.querySelectorAll('.exp-vscroll-panel') as NodeListOf<HTMLElement>;
    const items = track.querySelectorAll('.experience-item') as NodeListOf<HTMLElement>;
    const cards = track.querySelectorAll('.experience-card') as NodeListOf<HTMLElement>;
    const panelCount = panels.length;

    if (panelCount === 0) return () => {};

    const animDisabled = document.documentElement.getAttribute('data-animations') === 'disabled';

    if (animDisabled || isMobile()) {
      items.forEach((item) => item.classList.add('slide-in'));
      cards.forEach((c) => c.classList.add('content-in', 'highlights-in'));
      if (timelineLine) timelineLine.style.height = '100%';
      if (timelineEyes) timelineEyes.style.opacity = '1';
      if (isMobile()) {
        section.style.height = '';
        return () => {};
      }
    }

    // Reset timeline to initial state
    if (timelineLine) {
      timelineLine.style.height = '0px';
      timelineLine.style.transition = 'height 0.5s ease-out';
    }
    if (timelineEyes) {
      timelineEyes.style.opacity = '0';
      timelineEyes.style.top = '0px';
      timelineEyes.style.fontSize = '';
    }
    eyesBaseTop = 0;
    stopEyesHover();

    // Measure nav height
    const nav = document.getElementById('main-nav');
    const navH = nav ? nav.offsetHeight : 60;
    container.style.setProperty('--nav-h', `${navH}px`);

    // Calculate viewport height deterministically:
    // The sticky container is calc(100vh - navH), the header takes some of that,
    // and the rest is the viewport area for panels.
    const headerEl = container.querySelector('.exp-vscroll-header') as HTMLElement;
    const headerH = headerEl ? headerEl.offsetHeight : 0;
    const containerH = window.innerHeight - navH;
    const viewportH = containerH - headerH;

    // Set each panel to fill the viewport height
    panels.forEach((p) => { p.style.height = `${viewportH}px`; });



    // Step = viewport height (each panel is one viewport tall)
    const stepPx = viewportH;

    // Section height â€” add extra scroll space after last panel for the exit animation
    const scrollPerPanel = window.innerHeight * 0.7;
    const exitScrollPx = window.innerHeight * 0.4;
    section.style.height = `${window.innerHeight + (panelCount - 1) * scrollPerPanel + exitScrollPx}px`;

    // Line extends to center of viewport minus 75px, eyes sit at the tip
    const lineRestHeight = (viewportH / 2) - 75;

    let ticking = false;
    let snappedPanel = -1;
    let activeTimers: ReturnType<typeof setTimeout>[] = [];
    let hasExited = false;
    let isRecovering = false;

    function showTimeline(panelIndex: number) {
      if (!timelineLine) return;
      // Draw line down to rest position
      timelineLine.style.transition = 'height 0.5s ease-out';
      timelineLine.style.height = `${lineRestHeight}px`;

      if (timelineEyes && !isMobile()) {
        // Eyes ride down with the line tip
        eyesBaseTop = lineRestHeight;
        timelineEyes.style.transition = 'top 0.5s ease-out';
        timelineEyes.style.top = `${eyesBaseTop}px`;
        timelineEyes.style.opacity = '1';
        timelineEyes.style.fontSize = '';
        setEyesDirection(timelineEyes, panelIndex);
        // Start hovering after line finishes drawing
        activeTimers.push(setTimeout(() => {
          if (!timelineEyes) return;
          timelineEyes.style.transition = '';
          blinkEyes(timelineEyes);
          startEyesHover(timelineEyes);
        }, 520));
      }
    }

    function hideTimeline() {
      stopEyesHover();
      if (timelineLine) {
        timelineLine.style.transition = 'height 0.5s ease-out';
        timelineLine.style.height = '0px';
      }
      if (timelineEyes) {
        timelineEyes.style.transition = 'top 0.5s ease-out, opacity 0.3s ease-out';
        timelineEyes.style.top = '0px';
        timelineEyes.style.opacity = '0';
        timelineEyes.style.fontSize = '';
        eyesBaseTop = 0;
      }
    }

    function exitTimeline() {
      stopEyesHover();

      // Phase 1 (0â€“0.6s): Eyes move to top of line + grow 50%, line extends full viewport
      if (timelineEyes) {
        eyesBaseTop = 0;
        timelineEyes.style.transition = 'top 0.6s ease-in-out, font-size 0.6s ease-in-out';
        timelineEyes.style.top = '0px';
        timelineEyes.style.fontSize = '2.715rem';
      }

      if (timelineLine) {
        timelineLine.style.transition = 'height 0.6s ease-in-out';
        timelineLine.style.height = `${viewportH}px`;
      }

      // Phase 2 (0.6â€“2.5s): Eyes travel down the full line and fade out
      activeTimers.push(setTimeout(() => {
        if (!timelineEyes) return;
        playExitSlideSound();
        const travelDuration = 1.9; // remaining time: 2.5 - 0.6 = 1.9s
        timelineEyes.style.transition = `top ${travelDuration}s ease-in, opacity ${travelDuration * 0.6}s ease-in ${travelDuration * 0.4}s`;
        eyesBaseTop = viewportH + 50; // past the bottom edge
        timelineEyes.style.top = `${eyesBaseTop}px`;
        timelineEyes.style.opacity = '0';
      }, 620));
    }

    function updateEyesForPanel(panelIndex: number) {
      if (!timelineEyes || isMobile()) return;
      setEyesDirection(timelineEyes, panelIndex);

      // Peek up 75px quickly, then ease back to line tip, blink once settled, then hover
      stopEyesHover();
      const peekTop = eyesBaseTop - 75;
      timelineEyes.style.transition = 'top 0.15s ease-out';
      timelineEyes.style.top = `${peekTop}px`;
      activeTimers.push(setTimeout(() => {
        if (!timelineEyes) return;
        timelineEyes.style.transition = 'top 0.35s ease-in-out';
        timelineEyes.style.top = `${eyesBaseTop}px`;
        activeTimers.push(setTimeout(() => {
          if (!timelineEyes) return;
          blinkEyes(timelineEyes);
          timelineEyes.style.transition = '';
          startEyesHover(timelineEyes);
        }, 380));
      }, 170));
    }

    function revealPanel(index: number) {
      const item = items[index];
      const card = cards[index];
      if (!item || !card) return;

      activeTimers.push(setTimeout(() => {
        item.classList.add('slide-in');
      }, 50));

      activeTimers.push(setTimeout(() => {
        card.classList.add('content-in');
      }, 200));

      const highlights = card.querySelectorAll('.exp-highlight');
      highlights.forEach((h, i) => {
        activeTimers.push(setTimeout(() => {
          h.classList.add('visible');
        }, 400 + i * 80));
      });
      activeTimers.push(setTimeout(() => {
        card.classList.add('highlights-in');
      }, 300));
    }

    function resetAllPanels() {
      activeTimers.forEach((t) => clearTimeout(t));
      activeTimers = [];
      items.forEach((item) => {
        item.classList.remove('slide-in');
        item.style.transform = '';
        item.style.transition = '';
      });
      cards.forEach((c) => {
        c.classList.remove('content-in', 'highlights-in');
      });
    }

    function updateDots(activeIndex: number) {
      dots.forEach((dot, i) => {
        dot.classList.toggle('active', i === activeIndex);
      });
    }

    function snapTo(panelIndex: number) {
      const clamped = Math.max(0, Math.min(panelIndex, panelCount - 1));
      if (clamped === snappedPanel) return;

      snappedPanel = clamped;

      playSnapSound();
      resetAllPanels();

      const translatePx = clamped * stepPx;
      track.style.transition = 'transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      track.style.transform = `translateY(-${translatePx}px)`;

      updateDots(clamped);
      updateEyesForPanel(clamped);
      revealPanel(clamped);
    }

    function onScroll() {
      if (ticking) return;
      ticking = true;

      requestAnimationFrame(() => {
        const sectionRect = section.getBoundingClientRect();
        const sectionTop = -sectionRect.top;
        const totalScrollable = section.offsetHeight - window.innerHeight;
        // Where the last panel snap ends (before exit zone)
        const lastPanelEnd = (panelCount - 1) * scrollPerPanel;

        if (sectionTop < 0) {
          // Section hasn't scrolled to top yet
          isRecovering = false; // cancel any in-flight recovery
          if (sectionRect.top > window.innerHeight * 0.5) {
            // Section is far away â€” hide everything
            if (snappedPanel !== -1 || hasExited) {
              snappedPanel = -1;
              hasExited = false;
              resetAllPanels();
              track.style.transition = 'transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
              track.style.transform = 'translateY(0)';
              updateDots(0);
            }
            hideTimeline();
          } else {
            // Section is entering view â€” show first panel with timeline draw
            if (snappedPanel !== 0) {
              snappedPanel = 0;
              hasExited = false;
              playSnapSound();
              track.style.transition = 'transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
              track.style.transform = 'translateY(0)';
              updateDots(0);
              showTimeline(0);
              resetAllPanels();
              revealPanel(0);
            }
          }
        } else if (sectionTop > lastPanelEnd) {
          // We're past the last panel â€” enter exit zone
          // Cancel any in-flight recovery animation
          isRecovering = false;

          // First snap to last panel if not already there
          if (snappedPanel !== panelCount - 1) {
            snapTo(panelCount - 1);
          }

          if (!hasExited) {
            // Calculate exit progress (0 = just passed last panel, 1 = end of section)
            const exitProgress = Math.min((sectionTop - lastPanelEnd) / exitScrollPx, 1);

            if (exitProgress > 0.15) {
              hasExited = true;
              // Animate last card upward out of sight
              const lastItem = items[panelCount - 1];
              if (lastItem) {
                lastItem.style.transition = 'transform 0.5s ease-in, opacity 0.5s ease-in';
                lastItem.style.transform = 'translateY(-120%) translateX(0)';
                lastItem.classList.remove('slide-in');
              }
              // After card exits, animate timeline down and out
              activeTimers.push(setTimeout(() => {
                if (!hasExited) return; // cancelled if we scrolled back
                exitTimeline();
              }, 300));
            }
          }
        } else {
          // Normal panel scrolling zone

          // While recovery animation is playing, ignore normal scroll logic
          if (isRecovering) {
            ticking = false;
            return;
          }

          if (hasExited) {
            // Returning from exit â€” cancel all pending exit animations,
            // shrink line up, fade eyes out, then replay entrance.
            hasExited = false;
            isRecovering = true;

            // Cancel ALL pending timers (exit animation chain, etc.)
            activeTimers.forEach((t) => clearTimeout(t));
            activeTimers = [];
            stopEyesHover();

            // Phase 1: Eyes travel up to top and fade out, line shrinks to 0
            if (timelineEyes) {
              timelineEyes.style.transition = 'top 0.4s ease-in, opacity 0.3s ease-in 0.1s, font-size 0.3s ease-out';
              timelineEyes.style.top = '0px';
              timelineEyes.style.opacity = '0';
              timelineEyes.style.fontSize = '';
              eyesBaseTop = 0;
            }
            if (timelineLine) {
              timelineLine.style.transition = 'height 0.4s ease-in';
              timelineLine.style.height = '0px';
            }

            // Phase 2: After fade-out, snap eyes+line to top instantly, then replay entrance
            activeTimers.push(setTimeout(() => {
              if (!isRecovering) return;
              isRecovering = false;

              // Instantly reset eyes and line to starting position (no transition)
              if (timelineEyes) {
                timelineEyes.style.transition = 'none';
                timelineEyes.style.top = '0px';
                timelineEyes.style.opacity = '0';
                timelineEyes.style.fontSize = '';
                eyesBaseTop = 0;
              }
              if (timelineLine) {
                timelineLine.style.transition = 'none';
                timelineLine.style.height = '0px';
              }

              // Force layout so the instant reset takes effect before animating
              void container.offsetHeight;

              // Now replay the entrance â€” line draws down, eyes ride down
              // Always snap to last panel since we're coming back from exit
              const targetPanel = panelCount - 1;

              snappedPanel = targetPanel;
              track.style.transition = 'transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
              track.style.transform = `translateY(-${targetPanel * stepPx}px)`;
              updateDots(targetPanel);
              resetAllPanels();
              revealPanel(targetPanel);
              showTimeline(targetPanel);
            }, 450));

            ticking = false;
            return;
          }
          const progress = sectionTop / lastPanelEnd;
          const targetPanel = Math.round(progress * (panelCount - 1));
          snapTo(targetPanel);
        }

        ticking = false;
      });
    }

    // Dot click handlers
    dots.forEach((dot) => {
      dot.addEventListener('click', () => {
        const panelIndex = parseInt(dot.dataset.panel || '0', 10);
        const lastPanelEnd = (panelCount - 1) * scrollPerPanel;
        const targetScroll = section.offsetTop + (panelIndex / (panelCount - 1)) * lastPanelEnd;
        window.scrollTo({ top: targetScroll, behavior: 'smooth' });
      });
    });

    // Resize: full reinit
    let resizeTimer: ReturnType<typeof setTimeout>;
    function onResize() {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        expCleanup?.();
        expCleanup = initExpVscroll();
      }, 200);
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onResize, { passive: true });
    onScroll();

    return () => {
      window.removeEventListener('scroll', onScroll);
      window.removeEventListener('resize', onResize);
      clearTimeout(resizeTimer);
      stopEyesHover();
    };
  }

  // ============================================
  // Education
  // ============================================
  let waveCleanup: (() => void) | undefined;
  let eduCleanup: (() => void) | undefined;

  // Lazy-loaded education card tap sound
  let eduTapSound: HTMLAudioElement | null = null;
  const EDU_TAP_SOUND_URL = '/sounds/step_1-389275.mp3';

  function getEduTapSound(): HTMLAudioElement | null {
    if (!eduTapSound) {
      try {
        eduTapSound = new Audio(EDU_TAP_SOUND_URL);
        eduTapSound.volume = 0.25;
      } catch (_) { return null; }
    }
    return eduTapSound;
  }

  function playEduTapSound() {
    if (document.documentElement.getAttribute('data-sounds') === 'disabled') return;
    const snd = getEduTapSound();
    if (!snd) return;
    // Clone the audio so overlapping plays work
    const clone = snd.cloneNode() as HTMLAudioElement;
    clone.volume = snd.volume;
    clone.play().catch(() => {});
  }

  function initEducationCards() {
    const eduSection = document.querySelector('.education-section') as HTMLElement;
    const eduGrid = document.querySelector('.education-grid') as HTMLElement;
    if (!eduSection || !eduGrid) return () => {};

    if (document.documentElement.getAttribute('data-animations') === 'disabled') {
      eduSection.classList.add('visible');
      eduGrid.classList.add('cards-in');
      return () => {};
    }

    let ticking = false;
    let eduSoundsPlayed = false;
    let eduSoundTimers: ReturnType<typeof setTimeout>[] = [];

    function playEduCardSounds() {
      if (eduSoundsPlayed) return;
      eduSoundsPlayed = true;
      // Play a tap for each card, offset to match their CSS transition-delays
      const delays = [250, 350, 450, 550];
      delays.forEach((delay) => {
        eduSoundTimers.push(setTimeout(() => {
          playEduTapSound();
        }, delay));
      });
    }

    let cardsVisible = false;

    const checkEducation = () => {
      const viewportHeight = window.innerHeight;
      const titleTrigger = viewportHeight * 0.7;
      const cardsTrigger = viewportHeight * 0.5;
      const exitUpPoint = viewportHeight * 0.8;
      // Fire exit while section is still mostly visible
      const exitDownPoint = viewportHeight * 0.65;

      const sectionRect = eduSection.getBoundingClientRect();
      const gridRect = eduGrid.getBoundingClientRect();

      // Scrolled up past section â€” section top is below threshold
      const exitUp = sectionRect.top > exitUpPoint;
      // Scrolled down past section â€” section top is above threshold (still visible)
      const exitDown = sectionRect.top < -sectionRect.height * 0.35;

      if (exitUp || exitDown) {
        if (cardsVisible) {
          cardsVisible = false;
          eduSection.classList.remove('visible');
          eduGrid.classList.add('cards-out');
          eduGrid.classList.remove('cards-in');
          eduSoundsPlayed = false;
          eduSoundTimers.forEach((t) => clearTimeout(t));
          eduSoundTimers = [];
        }
      } else {
        // Remove cards-out when re-entering
        if (!cardsVisible && eduGrid.classList.contains('cards-out')) {
          eduGrid.classList.remove('cards-out');
        }
        if (sectionRect.top < titleTrigger) eduSection.classList.add('visible');
        if (gridRect.top < cardsTrigger && !cardsVisible) {
          cardsVisible = true;
          eduGrid.classList.add('cards-in');
          playEduCardSounds();
        }
      }

      ticking = false;
    };

    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(checkEducation);
        ticking = true;
      }
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    checkEducation();

    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }

  // Year counter animation
  function initYearCounters(skipInitialInView = false) {
    const counters = document.querySelectorAll('.year-counter');
    const animatedCounters = new Set<Element>();
    const wasOutOfView = new Set<Element>();
    const pendingTimeouts: number[] = [];

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          wasOutOfView.add(entry.target);
        } else if (entry.isIntersecting && !animatedCounters.has(entry.target)) {
          if (!skipInitialInView || wasOutOfView.has(entry.target)) {
            animatedCounters.add(entry.target);
            const target = entry.target as HTMLElement;
            const targetYear = parseInt(target.dataset.targetYear || '2000', 10);
            const timeoutId = window.setTimeout(() => {
              animateCounter(target, 2000, targetYear);
            }, 1000);
            pendingTimeouts.push(timeoutId);
          }
        }
      });
    }, { threshold: 0.5 });

    counters.forEach((counter) => {
      counter.textContent = '2000';
      observer.observe(counter);
    });

    return () => {
      observer.disconnect();
      animatedCounters.clear();
      wasOutOfView.clear();
      pendingTimeouts.forEach((id) => clearTimeout(id));
      pendingTimeouts.length = 0;
    };
  }

  function animateCounter(element: HTMLElement, start: number, end: number) {
    const duration = 1500;
    const startTime = performance.now();
    const range = end - start;

    function update(currentTime: number) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const easeOut = 1 - Math.pow(1 - progress, 3);
      const current = Math.round(start + range * easeOut);
      element.textContent = current.toString();
      if (progress < 1) requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
  }

  let yearCleanup: (() => void) | undefined;

  function initYears() {
    yearCleanup?.();
    yearCleanup = initYearCounters();
  }

  function resetYearCounters() {
    yearCleanup?.();
    document.querySelectorAll('.year-counter').forEach((counter) => {
      counter.textContent = '2000';
    });
    yearCleanup = initYearCounters(true);
  }

  // ============================================
  // Init all
  // ============================================
  function initAll() {
    expCleanup?.();
    expCleanup = initExpVscroll();
    initSectionParallax('experience');
    waveCleanup?.();
    waveCleanup = initScrollWave({
      selector: '.education-title',
      waveStart: 0.75,
      waveEnd: 0.35
    });
    eduCleanup?.();
    eduCleanup = initEducationCards();
    initYears();
  }

  initAll();
  document.addEventListener('astro:after-swap', initAll);

  window.addEventListener('animations-change', () => {
    expCleanup?.();
    expCleanup = initExpVscroll();
    waveCleanup?.();
    waveCleanup = initScrollWave({
      selector: '.education-title',
      waveStart: 0.75,
      waveEnd: 0.35
    });
    eduCleanup?.();
    eduCleanup = initEducationCards();
  });

  initYears();
  document.addEventListener('astro:after-swap', initYears);

  document.querySelectorAll('nav a[href^="#"], .back-to-top, a[href="#home"]').forEach((link) => {
    link.addEventListener('click', resetYearCounters);
  });
</script>
