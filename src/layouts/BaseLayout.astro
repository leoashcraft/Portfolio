---
import '../styles/global.css';
import SEOHead from '../components/common/SEOHead.astro';
import Header from '../components/common/Header.astro';
import Footer from '../components/common/Footer.astro';
import CustomCursor from '../components/common/CustomCursor.astro';

interface Props {
  title?: string;
  description?: string;
  image?: string;
  type?: 'website' | 'article' | 'profile';
  publishedTime?: Date;
  modifiedTime?: Date;
  tags?: string[];
  noindex?: boolean;
}

const props = Astro.props;
---

<!doctype html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <SEOHead {...props} />
  </head>
  <body class="custom-cursor">
    <!-- Skip to main content (Accessibility) -->
    <a href="#main-content" class="skip-link">
      Skip to main content
    </a>

    <!-- Custom Cursor -->
    <CustomCursor />

    <!-- Header/Navigation -->
    <Header />

    <!-- Main Content -->
    <main id="main-content" tabindex="-1">
      <slot />
    </main>

    <!-- Footer -->
    <Footer />

    <!-- Back to Top Button -->
    <button
      id="back-to-top"
      class="fixed bottom-6 right-6 w-12 h-12 rounded-full bg-neon-pink/20 border border-neon-pink/40 text-neon-pink opacity-0 invisible translate-y-4 transition-all duration-300 hover:bg-neon-pink/30 hover:border-neon-pink/60 hover:scale-110 z-50 flex items-center justify-center"
      aria-label="Back to top"
      style="box-shadow: 0 0 15px rgba(255, 0, 255, 0.2);"
    >
      <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
      </svg>
    </button>

    <script>
      function initBackToTop() {
        const btn = document.getElementById('back-to-top');
        if (!btn) return;

        const showThreshold = 400;

        function updateButton() {
          if (window.scrollY > showThreshold) {
            btn.classList.remove('opacity-0', 'invisible', 'translate-y-4');
            btn.classList.add('opacity-100', 'visible', 'translate-y-0');
          } else {
            btn.classList.remove('opacity-100', 'visible', 'translate-y-0');
            btn.classList.add('opacity-0', 'invisible', 'translate-y-4');
          }
        }

        window.addEventListener('scroll', updateButton, { passive: true });
        updateButton();

        btn.addEventListener('click', () => {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
      }

      function initSectionTitleWave() {
        const titles = document.querySelectorAll('.section-title');
        const animatedTitles = new Set<Element>();

        // Function to wrap text in letter spans
        function wrapLetters(element: Element) {
          const childNodes = Array.from(element.childNodes);

          childNodes.forEach((node) => {
            if (node.nodeType === Node.TEXT_NODE && node.textContent) {
              const text = node.textContent;
              const fragment = document.createDocumentFragment();

              for (const char of text) {
                if (char === ' ') {
                  fragment.appendChild(document.createTextNode(' '));
                } else {
                  const span = document.createElement('span');
                  span.className = 'wave-letter';
                  span.textContent = char;
                  fragment.appendChild(span);
                }
              }

              node.replaceWith(fragment);
            } else if (node.nodeType === Node.ELEMENT_NODE) {
              // Recursively wrap letters in child elements (like gradient-text spans)
              wrapLetters(node as Element);
            }
          });
        }

        // Function to animate the wave
        function animateWave(title: Element) {
          const letters = title.querySelectorAll('.wave-letter');
          let delay = 0;
          const delayIncrement = 50; // ms between each letter

          letters.forEach((letter, index) => {
            setTimeout(() => {
              letter.classList.add('animating');

              // Remove animation class after it completes
              setTimeout(() => {
                letter.classList.remove('animating');
              }, 400);
            }, delay);

            delay += delayIncrement;
          });

          // Add sheen effect after wave completes
          const totalWaveTime = delay + 400;
          setTimeout(() => {
            title.classList.add('sheen');

            // Remove sheen class after animation
            setTimeout(() => {
              title.classList.remove('sheen');
            }, 800);
          }, totalWaveTime);
        }

        // Intersection Observer to trigger animation
        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting && !animatedTitles.has(entry.target)) {
                animatedTitles.add(entry.target);

                // Wrap letters if not already done
                if (!entry.target.querySelector('.wave-letter')) {
                  wrapLetters(entry.target);
                }

                // Small delay before starting animation
                setTimeout(() => {
                  animateWave(entry.target);
                }, 200);
              }
            });
          },
          {
            threshold: 0.5,
            rootMargin: '0px 0px -10% 0px'
          }
        );

        titles.forEach((title) => {
          observer.observe(title);
        });
      }

      initBackToTop();
      initSectionTitleWave();
      document.addEventListener('astro:after-swap', () => {
        initBackToTop();
        initSectionTitleWave();
      });
    </script>
  </body>
</html>
