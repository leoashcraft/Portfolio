---
import '../styles/global.css';
import SEOHead from '../components/common/SEOHead.astro';
import Header from '../components/common/Header.astro';
import Footer from '../components/common/Footer.astro';
import CustomCursor from '../components/common/CustomCursor.astro';

interface Props {
  title?: string;
  description?: string;
  image?: string;
  type?: 'website' | 'article' | 'profile';
  publishedTime?: Date;
  modifiedTime?: Date;
  tags?: string[];
  noindex?: boolean;
}

const props = Astro.props;
---

<!doctype html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <SEOHead {...props} />
  </head>
  <body class="custom-cursor">
    <!-- Skip to main content (Accessibility) -->
    <a href="#main-content" class="skip-link">
      Skip to main content
    </a>

    <!-- Custom Cursor -->
    <CustomCursor />

    <!-- Header/Navigation -->
    <Header />

    <!-- Main Content -->
    <main id="main-content" tabindex="-1">
      <slot />
    </main>

    <!-- Footer -->
    <Footer />

    <!-- Back to Top Button -->
    <button
      id="back-to-top"
      class="fixed bottom-6 right-6 w-12 h-12 rounded-full bg-neon-pink/20 border border-neon-pink/40 text-neon-pink opacity-0 invisible translate-y-4 transition-all duration-300 hover:bg-neon-pink/30 hover:border-neon-pink/60 hover:scale-110 z-50 flex items-center justify-center"
      aria-label="Back to top"
      style="box-shadow: 0 0 15px rgba(255, 0, 255, 0.2);"
    >
      <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
      </svg>
    </button>

    <script>
      function initBackToTop() {
        const btn = document.getElementById('back-to-top');
        if (!btn) return;

        const showThreshold = 400;

        function updateButton() {
          if (window.scrollY > showThreshold) {
            btn.classList.remove('opacity-0', 'invisible', 'translate-y-4');
            btn.classList.add('opacity-100', 'visible', 'translate-y-0');
          } else {
            btn.classList.remove('opacity-100', 'visible', 'translate-y-0');
            btn.classList.add('opacity-0', 'invisible', 'translate-y-4');
          }
        }

        window.addEventListener('scroll', updateButton, { passive: true });
        updateButton();

        btn.addEventListener('click', () => {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
      }

      function initSectionTitleWave() {
        // Target both section titles and the hero title
        const titles = document.querySelectorAll('.section-title, .hero-title');
        const animatedTitles = new Set<Element>();

        // Function to collect ALL text content and wrap in letter spans
        function wrapAllLetters(element: Element): HTMLSpanElement[] {
          const allLetterSpans: HTMLSpanElement[] = [];

          function processNode(node: Node, parentElement: Element | null) {
            if (node.nodeType === Node.TEXT_NODE && node.textContent) {
              const text = node.textContent;
              const fragment = document.createDocumentFragment();

              // Check if parent has gradient-text class and get its gradient
              const isGradient = parentElement?.classList.contains('gradient-text') ||
                                 parentElement?.classList.contains('gradient-text-animated');
              let gradientStyle = '';
              if (isGradient && parentElement) {
                gradientStyle = getComputedStyle(parentElement).backgroundImage;
              }

              for (const char of text) {
                if (char === ' ' || char === '\n' || char === '\t') {
                  fragment.appendChild(document.createTextNode(char));
                } else {
                  const span = document.createElement('span');
                  span.className = 'wave-letter';
                  span.style.display = 'inline-block';
                  span.textContent = char;

                  // If inside gradient-text, apply gradient to each letter
                  if (isGradient && gradientStyle) {
                    span.style.backgroundImage = gradientStyle;
                    span.style.backgroundClip = 'text';
                    span.style.webkitBackgroundClip = 'text';
                    span.style.color = 'transparent';
                  }

                  fragment.appendChild(span);
                  allLetterSpans.push(span);
                }
              }

              node.replaceWith(fragment);
            } else if (node.nodeType === Node.ELEMENT_NODE) {
              // Process children of element nodes (like gradient-text spans)
              const el = node as Element;
              const children = Array.from(el.childNodes);
              children.forEach(child => processNode(child, el));
            }
          }

          const childNodes = Array.from(element.childNodes);
          childNodes.forEach(child => processNode(child, null));

          return allLetterSpans;
        }

        // Function to animate using direct style manipulation
        function animateWave(letters: HTMLSpanElement[]) {
          const delayIncrement = 50;
          const waveDuration = 400;
          const sheenDelayIncrement = 30;
          const sheenDuration = 300;

          // Wave animation - scale each letter
          letters.forEach((letter, index) => {
            const delay = index * delayIncrement;

            setTimeout(() => {
              letter.style.transition = `transform ${waveDuration}ms ease-in-out`;
              letter.style.transform = 'scale(1.4)';

              setTimeout(() => {
                letter.style.transform = 'scale(1)';
              }, waveDuration / 2);
            }, delay);
          });

          // Sheen animation - brightness filter sweep
          const totalWaveTime = letters.length * delayIncrement + waveDuration;
          setTimeout(() => {
            letters.forEach((letter, index) => {
              const sheenDelay = index * sheenDelayIncrement;

              setTimeout(() => {
                letter.style.transition = `filter ${sheenDuration}ms ease-in-out`;
                letter.style.filter = 'brightness(1.5) drop-shadow(0 0 6px rgba(255, 255, 255, 0.6))';

                setTimeout(() => {
                  letter.style.filter = '';
                }, sheenDuration / 2);
              }, sheenDelay);
            });
          }, totalWaveTime);
        }

        // Intersection Observer to trigger animation
        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting && !animatedTitles.has(entry.target)) {
                animatedTitles.add(entry.target);

                // Wrap letters and get them in order
                const letters = wrapAllLetters(entry.target);

                // Small delay before starting animation
                setTimeout(() => {
                  animateWave(letters);
                }, 200);
              }
            });
          },
          {
            threshold: 0.5,
            rootMargin: '0px 0px -10% 0px'
          }
        );

        titles.forEach((title) => {
          observer.observe(title);
        });
      }

      initBackToTop();
      initSectionTitleWave();
      document.addEventListener('astro:after-swap', () => {
        initBackToTop();
        initSectionTitleWave();
      });
    </script>
  </body>
</html>
